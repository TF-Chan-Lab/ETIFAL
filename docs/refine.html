---

title: refine


keywords: fastai
sidebar: home_sidebar



nb_path: "05_refine.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 05_refine.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">sub</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">mean</span>
<span class="kn">from</span> <span class="nn">LAFITE.utils</span> <span class="kn">import</span> <span class="n">loc_distance</span><span class="p">,</span> <span class="n">Vividict</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="AttributeCollection" class="doc_header"><code>class</code> <code>AttributeCollection</code><a href="https://github.com/TF-Chan-Lab/LAFITE/tree/master/LAFITE/refine.py#L19" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>AttributeCollection</code>(<strong><code>start</code></strong>:<code>int</code>, <strong><code>end</code></strong>:<code>int</code>, <strong><code>count</code></strong>:<code>float</code>, <strong><code>polya_count</code></strong>:<code>int</code>=<em><code>None</code></em>, <strong><code>fsm</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>polyaed</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>as_site</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>apa_site</code></strong>:<code>list</code>=<em><code>None</code></em>, <strong><code>name</code></strong>:<code>str</code>=<em><code>None</code></em>, <strong><code>rss_dis</code></strong>:<code>int</code>=<em><code>inf</code></em>, <strong><code>read_tag</code></strong>:<code>str</code>=<em><code>None</code></em>, <strong><code>processed</code></strong>:<code>bool</code>=<em><code>False</code></em>, <strong><code>chrand_ID</code></strong>:<code>int</code>=<em><code>None</code></em>, <strong><code>loci_ID</code></strong>:<code>int</code>=<em><code>None</code></em>)</p>
</blockquote>
<p>AttributeCollection(start: int, end: int, count: float, polya_count: int = None, fsm: bool = False, polyaed: bool = False, as_site: list = None, apa_site: list = None, name: str = None, rss_dis: int = inf, read_tag: str = None, processed: bool = False, chrand_ID: int = None, loci_ID: int = None)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">@</span> <span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">AttributeCollection</span><span class="p">:</span>
	<span class="n">start</span><span class="p">:</span> <span class="nb">int</span>
	<span class="n">end</span><span class="p">:</span> <span class="nb">int</span>
	<span class="n">count</span><span class="p">:</span> <span class="nb">float</span>
	<span class="n">polya_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="n">fsm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
	<span class="n">polyaed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
	<span class="n">as_site</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="n">apa_site</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="n">rss_dis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
	<span class="n">read_tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="n">processed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
	<span class="n">chrand_ID</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="n">loci_ID</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SingleExonReadRefine" class="doc_header"><code>class</code> <code>SingleExonReadRefine</code><a href="https://github.com/TF-Chan-Lab/LAFITE/tree/master/LAFITE/refine.py#L38" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SingleExonReadRefine</code>(<strong><code>chrom</code></strong>, <strong><code>strand</code></strong>, <strong><code>chrand_collected_single_exon_read</code></strong>, <strong><code>chrand_ref_single_exon_trans</code></strong>, <strong><code>chrand_ref_mutple_exon_trans</code></strong>, <strong><code>chrand_three_prime_exon</code></strong>, <strong><code>min_single_exon_coverage</code></strong>, <strong><code>min_single_exon_len</code></strong>, <strong><code>rs_tolerance</code></strong>=<em><code>24</code></em>, <strong><code>coverage_cliff</code></strong>=<em><code>0</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">SingleExonReadRefine</span><span class="p">:</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">chrand_collected_single_exon_read</span><span class="p">,</span> <span class="n">chrand_ref_single_exon_trans</span><span class="p">,</span> <span class="n">chrand_ref_mutple_exon_trans</span><span class="p">,</span> <span class="n">chrand_three_prime_exon</span><span class="p">,</span> <span class="n">min_single_exon_coverage</span><span class="p">,</span> <span class="n">min_single_exon_len</span><span class="p">,</span> <span class="n">rs_tolerance</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="n">coverage_cliff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">chrom</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="n">strand</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chrand_collected_single_exon_read</span> <span class="o">=</span> <span class="n">chrand_collected_single_exon_read</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chrand_ref_single_exon_trans</span> <span class="o">=</span> <span class="n">chrand_ref_single_exon_trans</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chrand_ref_mutple_exon_trans</span> <span class="o">=</span> <span class="n">chrand_ref_mutple_exon_trans</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chrand_three_prime_exon</span> <span class="o">=</span> <span class="n">chrand_three_prime_exon</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">min_single_exon_coverage</span> <span class="o">=</span> <span class="n">min_single_exon_coverage</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">min_single_exon_len</span> <span class="o">=</span> <span class="n">min_single_exon_len</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span> <span class="o">=</span> <span class="n">rs_tolerance</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">coverage_cliff</span> <span class="o">=</span> <span class="n">coverage_cliff</span>

	<span class="k">def</span> <span class="nf">single_exon_refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subread</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">refined_single_exon_read</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">subread</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">subread</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_single_exon_len</span><span class="p">:</span>
			<span class="n">subread_attribute</span> <span class="o">=</span> <span class="n">AttributeCollection</span><span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">mean</span><span class="p">(</span><span class="n">coverage</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">subread</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrand_ref_single_exon_trans</span><span class="p">:</span>
				<span class="n">overlap_ref</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrand_ref_single_exon_trans</span><span class="o">.</span><span class="n">find</span><span class="p">((</span><span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">1</span><span class="p">]])))</span>
				<span class="k">if</span> <span class="n">overlap_ref</span><span class="p">:</span>
					<span class="k">for</span> <span class="n">ref_exon</span> <span class="ow">in</span> <span class="n">overlap_ref</span><span class="p">:</span>
						<span class="n">overlap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ref_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ref_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
						<span class="n">overlap</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">overlap</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">ref_exon</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ref_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
							<span class="n">subread_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
							<span class="n">subread_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Keep_ref&#39;</span>
							<span class="k">break</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">subread_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrand_three_prime_exon</span><span class="p">:</span>
				<span class="n">overlap_ref</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrand_three_prime_exon</span><span class="o">.</span><span class="n">find</span><span class="p">((</span><span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">1</span><span class="p">]])))</span>
				<span class="k">if</span> <span class="n">overlap_ref</span><span class="p">:</span>
					<span class="k">for</span> <span class="n">ref_exon</span> <span class="ow">in</span> <span class="n">overlap_ref</span><span class="p">:</span>
						<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">and</span> <span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">ref_exon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">ref_exon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span><span class="p">):</span>
							<span class="n">subread_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
							<span class="k">break</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">subread_attribute</span><span class="o">.</span><span class="n">processed</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">subread_attribute</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_single_exon_coverage</span><span class="p">:</span>
					<span class="n">subread_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
					<span class="n">subread_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Keep_coverage&#39;</span>
			<span class="k">if</span> <span class="n">subread_attribute</span><span class="o">.</span><span class="n">read_tag</span><span class="p">:</span>
				<span class="n">refined_single_exon_read</span><span class="p">[(</span><span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">position</span><span class="p">[</span><span class="n">subread</span><span class="p">[</span><span class="mi">1</span><span class="p">]])]</span> <span class="o">=</span> <span class="n">subread_attribute</span>
		<span class="n">subread</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">subread</span><span class="p">,</span> <span class="n">refined_single_exon_read</span>

	<span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">refined_single_exon_read</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
		<span class="n">chrand_collected_single_exon_read</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrand_collected_single_exon_read</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
		<span class="n">position</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chrand_collected_single_exon_read</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
		<span class="n">coverage</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chrand_collected_single_exon_read</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
		<span class="n">subread</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrand_ref_mutple_exon_trans</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">coverage_cliff</span> <span class="o">=</span> <span class="mf">0.9</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">and</span> <span class="n">coverage</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">coverage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coverage_cliff</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="n">coverage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">coverage</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coverage_cliff</span><span class="p">)):</span>
				<span class="n">subread</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
				<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
					<span class="n">subread</span><span class="p">,</span> <span class="n">refined_single_exon_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_exon_refine</span><span class="p">(</span><span class="n">subread</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">refined_single_exon_read</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">subread</span><span class="p">,</span> <span class="n">refined_single_exon_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_exon_refine</span><span class="p">(</span><span class="n">subread</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">refined_single_exon_read</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span><span class="p">,</span> <span class="n">refined_single_exon_read</span>
		
		
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="MultiExonReadRefine" class="doc_header"><code>class</code> <code>MultiExonReadRefine</code><a href="https://github.com/TF-Chan-Lab/LAFITE/tree/master/LAFITE/refine.py#L101" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>MultiExonReadRefine</code>(<strong><code>chrom</code></strong>, <strong><code>strand</code></strong>, <strong><code>chrand_processed_collected_multi_exon_read</code></strong>, <strong><code>chrand_ref_mutple_exon_trans</code></strong>, <strong><code>chrand_tss_dict</code></strong>, <strong><code>tss_cutoff</code></strong>, <strong><code>tes_cutoff</code></strong>, <strong><code>min_novel_trans_count</code></strong>, <strong><code>relative_fl_coverage</code></strong>=<em><code>5</code></em>, <strong><code>rs_tolerance</code></strong>=<em><code>24</code></em>, <strong><code>re_tolerance</code></strong>=<em><code>50</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">MultiExonReadRefine</span><span class="p">():</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">chrand_processed_collected_multi_exon_read</span><span class="p">,</span> <span class="n">chrand_ref_mutple_exon_trans</span><span class="p">,</span> <span class="n">chrand_tss_dict</span><span class="p">,</span> <span class="n">tss_cutoff</span><span class="p">,</span> <span class="n">tes_cutoff</span><span class="p">,</span> <span class="n">min_novel_trans_count</span><span class="p">,</span> <span class="n">relative_fl_coverage</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rs_tolerance</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">re_tolerance</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">chrom</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="n">strand</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chrand_processed_collected_multi_exon_read</span> <span class="o">=</span> <span class="n">chrand_processed_collected_multi_exon_read</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chrand_ref_mutple_exon_trans</span> <span class="o">=</span> <span class="n">chrand_ref_mutple_exon_trans</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chrand_tss_dict</span> <span class="o">=</span> <span class="n">chrand_tss_dict</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tss_cutoff</span> <span class="o">=</span> <span class="n">tss_cutoff</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tes_cutoff</span> <span class="o">=</span> <span class="n">tes_cutoff</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span> <span class="o">=</span> <span class="n">rs_tolerance</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">re_tolerance</span> <span class="o">=</span> <span class="n">re_tolerance</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">min_novel_trans_count</span> <span class="o">=</span> <span class="n">min_novel_trans_count</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">relative_fl_coverage</span> <span class="o">=</span> <span class="n">relative_fl_coverage</span>

	<span class="k">def</span> <span class="nf">trucated_reads_filtering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">trans_structure_pool</span><span class="p">,</span> <span class="n">refined_multi_exon_read</span><span class="p">,</span> <span class="n">total_count</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">ref_iso_splicing</span> <span class="ow">in</span> <span class="n">trans_structure_pool</span><span class="p">:</span>
			<span class="n">tmp_tag</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)):</span>
					<span class="n">idx_start</span> <span class="o">=</span> <span class="n">ref_iso_splicing</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
					<span class="n">idx_end</span> <span class="o">=</span> <span class="n">ref_iso_splicing</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
					<span class="k">if</span> <span class="n">corrected_read_splicing</span> <span class="o">==</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
						<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">and</span> <span class="n">idx_start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
							<span class="k">if</span> <span class="n">idx_end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
								<span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_start</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span><span class="p">:</span>
									<span class="n">tmp_tag</span> <span class="o">=</span> <span class="s1">&#39;Disqualify_Trucated_ISM&#39;</span>
							<span class="k">else</span><span class="p">:</span>
								<span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_start</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_tolerance</span><span class="p">:</span>
									<span class="n">tmp_tag</span> <span class="o">=</span> <span class="s1">&#39;Disqualify_Trucated_ISM&#39;</span>

						<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="n">idx_end</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
							<span class="k">if</span> <span class="n">idx_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
								<span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span><span class="p">:</span>
									<span class="n">tmp_tag</span> <span class="o">=</span> <span class="s1">&#39;Disqualify_Trucated_ISM&#39;</span>
							<span class="k">else</span><span class="p">:</span>
								<span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_start</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span><span class="p">:</span>
									<span class="n">tmp_tag</span> <span class="o">=</span> <span class="s1">&#39;Disqualify_Trucated_ISM&#39;</span>
					<span class="k">if</span> <span class="n">tmp_tag</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">ref_iso_splicing</span> <span class="ow">in</span> <span class="n">refined_multi_exon_read</span><span class="p">:</span>
							<span class="k">if</span> <span class="n">total_count</span><span class="o">/</span><span class="n">refined_multi_exon_read</span><span class="p">[</span><span class="n">ref_iso_splicing</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_fl_coverage</span><span class="p">:</span>
								<span class="n">tmp_tag</span> <span class="o">=</span> <span class="kc">None</span>
					<span class="k">if</span> <span class="n">tmp_tag</span><span class="p">:</span>
						<span class="k">break</span>
		<span class="k">return</span> <span class="n">tmp_tag</span>

	<span class="k">def</span> <span class="nf">ISM_NIC_sorting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">trans_structure_pool</span><span class="p">,</span> <span class="n">rss_dis</span><span class="p">,</span> <span class="n">total_count</span><span class="p">,</span> <span class="n">start_pos</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">relative_intact</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">tmp_tag</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">ref_iso_splicing</span> <span class="ow">in</span> <span class="n">trans_structure_pool</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)):</span>
					<span class="n">idx_start</span> <span class="o">=</span> <span class="n">ref_iso_splicing</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
					<span class="n">idx_end</span> <span class="o">=</span> <span class="n">ref_iso_splicing</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
					<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">and</span> <span class="n">idx_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="n">idx_end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
						<span class="n">start_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">start_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
					<span class="n">ref_exon_num</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> 
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
						<span class="n">relative_intact</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ref_exon_num</span> <span class="o">-</span> <span class="n">idx_start</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">ref_exon_num</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">relative_intact</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">idx_end</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">ref_exon_num</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">start_pos</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">start_pos</span><span class="p">)</span> <span class="ow">or</span> <span class="n">rss_dis</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tss_cutoff</span><span class="p">:</span>
				<span class="n">tmp_tag</span> <span class="o">=</span> <span class="s1">&#39;Subset&#39;</span>
			<span class="k">elif</span> <span class="n">total_count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_novel_trans_count</span> <span class="ow">and</span> <span class="n">mean</span><span class="p">(</span><span class="n">relative_intact</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
				<span class="n">tmp_tag</span> <span class="o">=</span> <span class="s1">&#39;Subset_coverage&#39;</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">tmp_tag</span> <span class="o">=</span> <span class="s1">&#39;Disqualify_ISM_NIC&#39;</span>
		
		<span class="k">return</span> <span class="n">tmp_tag</span>

	
	<span class="k">def</span> <span class="nf">closest_ref_trans</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">trans_structure_pool</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot; return the closest reference transcripts for the input read</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">inter_SJ</span> <span class="o">=</span> <span class="p">()</span>
		<span class="n">cmp_trans</span> <span class="o">=</span> <span class="p">()</span>
		<span class="k">for</span> <span class="n">ref_iso_splicing</span> <span class="ow">in</span> <span class="n">trans_structure_pool</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
				<span class="n">ref_iso_splicing</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">))</span>
				<span class="n">corrected_read_splicing</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">))</span>

			<span class="n">tmp_inter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">)))</span>
			<span class="n">tmp_inter</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_inter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_SJ</span><span class="p">):</span>
				<span class="n">inter_SJ</span><span class="p">,</span> <span class="n">cmp_trans</span> <span class="o">=</span> <span class="n">tmp_inter</span><span class="p">,</span> <span class="n">ref_iso_splicing</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_inter</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_SJ</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_inter</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">index1</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cmp_trans</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">inter_SJ</span><span class="p">]</span> 
				<span class="n">index2</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">tmp_inter</span><span class="p">]</span> 
				<span class="n">index_sub</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">))</span>
				<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">index_sub</span><span class="p">):</span>
					<span class="k">if</span> <span class="n">index_sub</span><span class="p">[</span><span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index_sub</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">),</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
						<span class="n">inter_SJ</span> <span class="o">=</span> <span class="n">tmp_inter</span>
						<span class="n">cmp_trans</span> <span class="o">=</span> <span class="n">ref_iso_splicing</span>
				<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cmp_trans</span><span class="p">):</span>
					<span class="n">inter_SJ</span> <span class="o">=</span> <span class="n">tmp_inter</span>
					<span class="n">cmp_trans</span> <span class="o">=</span> <span class="n">ref_iso_splicing</span>
		
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
			<span class="n">cmp_trans</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">cmp_trans</span><span class="p">))</span>

		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_SJ</span><span class="p">),</span> <span class="n">cmp_trans</span>
	
	<span class="k">def</span> <span class="nf">secondary_refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">read_attribute</span><span class="p">,</span> <span class="n">refined_multi_exon_read</span><span class="p">,</span> <span class="n">loci_idx</span><span class="p">):</span>
		<span class="k">if</span> <span class="s1">&#39;Disqualify&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">!=</span> <span class="s1">&#39;Reference&#39;</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">ref_iso_splicing</span> <span class="ow">in</span> <span class="n">refined_multi_exon_read</span><span class="p">:</span>
					<span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)):</span>
						<span class="n">idx_start</span> <span class="o">=</span> <span class="n">ref_iso_splicing</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
						<span class="n">idx_end</span> <span class="o">=</span> <span class="n">ref_iso_splicing</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
						<span class="k">if</span> <span class="n">corrected_read_splicing</span> <span class="o">==</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
							<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">and</span> <span class="n">idx_end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_iso_splicing</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="ow">and</span> <span class="n">idx_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
								<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span> <span class="ow">and</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_start</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span> <span class="ow">and</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">ref_iso_splicing</span><span class="p">[</span><span class="n">idx_end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rs_tolerance</span><span class="p">):</span>
									<span class="k">if</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">count</span><span class="o">/</span><span class="n">refined_multi_exon_read</span><span class="p">[</span><span class="n">ref_iso_splicing</span><span class="p">]</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_fl_coverage</span><span class="p">:</span>
										<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Disqualify_merged&#39;</span>
										<span class="k">break</span>

		<span class="k">if</span> <span class="s1">&#39;Disqualify&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span><span class="p">:</span>
			<span class="n">len_inter_SJ</span><span class="p">,</span> <span class="n">cmp_trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_ref_trans</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">refined_multi_exon_read</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">len_inter_SJ</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">read_attribute</span><span class="o">.</span><span class="n">chrand_ID</span> <span class="o">=</span> <span class="n">refined_multi_exon_read</span><span class="p">[</span><span class="n">cmp_trans</span><span class="p">]</span><span class="o">.</span><span class="n">chrand_ID</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">loci_idx</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="n">read_attribute</span><span class="o">.</span><span class="n">chrand_ID</span> <span class="o">=</span> <span class="n">loci_idx</span>

			<span class="n">refined_multi_exon_read</span><span class="p">[</span><span class="n">corrected_read_splicing</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_attribute</span>

		<span class="k">return</span> <span class="n">refined_multi_exon_read</span><span class="p">,</span> <span class="n">read_attribute</span><span class="p">,</span> <span class="n">loci_idx</span>


	<span class="k">def</span> <span class="nf">main_refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loci_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
		<span class="n">refined_multi_exon_read</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
		<span class="n">refine_log</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">read_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrand_processed_collected_multi_exon_read</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">read_attribute</span> <span class="o">=</span> <span class="n">AttributeCollection</span><span class="p">(</span><span class="o">*</span><span class="n">read_info</span><span class="p">)</span>
			<span class="n">trans_structure_pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrand_ref_mutple_exon_trans</span>

			<span class="c1"># calculate the distance between TSS of the collapsed read and nearest reference TSS</span>
			<span class="n">read_attribute</span><span class="o">.</span><span class="n">rss_dis</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">loc_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrand_tss_dict</span><span class="p">,</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

			<span class="c1"># check full splicing match reads whose rss and exactly matched reference transcripts </span>
			<span class="k">if</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">fsm</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">trans_structure_pool</span><span class="p">[</span><span class="n">corrected_read_splicing</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tss_cutoff</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">as_site</span><span class="p">):</span>
					<span class="k">if</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">polyaed</span><span class="p">:</span>
						<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Reference&#39;</span>
						<span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
					<span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">trans_structure_pool</span><span class="p">[</span><span class="n">corrected_read_splicing</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tes_cutoff</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">apa_site</span><span class="p">):</span>
						<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Reference&#39;</span>
						<span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>

			<span class="k">if</span> <span class="ow">not</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span><span class="p">:</span>
				<span class="c1"># check if read is trucated</span>
				<span class="k">if</span> <span class="n">trans_structure_pool</span><span class="p">:</span>
					<span class="n">read_tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trucated_reads_filtering</span><span class="p">(</span><span class="n">read_attribute</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">trans_structure_pool</span><span class="p">,</span> <span class="n">refined_multi_exon_read</span><span class="p">,</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">read_tag</span><span class="p">:</span>
						<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="n">read_tag</span>
						<span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>

				<span class="k">if</span> <span class="ow">not</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="ow">and</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">fsm</span><span class="p">:</span>
					<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Reference&#39;</span>
					<span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
				
				<span class="k">if</span> <span class="ow">not</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">polyaed</span><span class="p">:</span>
					<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Disqualify_No_ployA&#39;</span>
					<span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
					
				<span class="k">elif</span> <span class="ow">not</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">trans_structure_pool</span><span class="p">:</span>
						<span class="n">read_tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ISM_NIC_sorting</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">trans_structure_pool</span><span class="p">,</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">rss_dis</span><span class="p">,</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">start_pos</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">tmp_tag</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
						<span class="k">if</span> <span class="n">read_tag</span><span class="p">:</span>
							<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="n">read_tag</span>
							<span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>

					<span class="k">if</span> <span class="ow">not</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span><span class="p">:</span>
						<span class="n">len_inter_SJ</span><span class="p">,</span> <span class="n">cmp_trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_ref_trans</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">trans_structure_pool</span><span class="p">)</span>
						<span class="n">read_attribute</span><span class="o">.</span><span class="n">processed</span> <span class="o">=</span> <span class="kc">True</span>
						<span class="k">if</span> <span class="n">len_inter_SJ</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">cmp_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">corrected_read_splicing</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">cmp_trans</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">))</span> <span class="ow">or</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">rss_dis</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tss_cutoff</span><span class="p">:</span>
								<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Similar&#39;</span>
							<span class="k">else</span><span class="p">:</span>
								<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Disqualify_NNC&#39;</span>
						<span class="k">else</span><span class="p">:</span>
							<span class="k">if</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">rss_dis</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tss_cutoff</span> <span class="ow">or</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">count</span>  <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_novel_trans_count</span><span class="p">:</span>
								<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s1">&#39;Novel_loci&#39;</span>
							<span class="k">else</span><span class="p">:</span>
								<span class="n">read_attribute</span><span class="o">.</span><span class="n">read_tag</span> <span class="o">=</span> <span class="s2">&quot;Disqualify_Other&quot;</span>
			
			<span class="n">refined_multi_exon_read</span><span class="p">,</span> <span class="n">read_attribute</span><span class="p">,</span> <span class="n">loci_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">secondary_refine</span><span class="p">(</span><span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">read_attribute</span><span class="p">,</span> <span class="n">refined_multi_exon_read</span><span class="p">,</span> <span class="n">loci_idx</span><span class="p">)</span>
			<span class="n">refine_log</span><span class="p">[</span><span class="n">corrected_read_splicing</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_attribute</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span><span class="p">,</span> <span class="n">refined_multi_exon_read</span><span class="p">,</span> <span class="n">refine_log</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="RefineWrapper" class="doc_header"><code>class</code> <code>RefineWrapper</code><a href="https://github.com/TF-Chan-Lab/LAFITE/tree/master/LAFITE/refine.py#L294" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>RefineWrapper</code>(<strong><code>processed_collected_multi_exon_read</code></strong>, <strong><code>collected_single_exon_read</code></strong>, <strong><code>ref_mutple_exon_trans</code></strong>, <strong><code>ref_single_exon_trans</code></strong>, <strong><code>three_prime_exon</code></strong>, <strong><code>tss_dict</code></strong>, <strong><code>tss_cutoff</code></strong>, <strong><code>tes_cutoff</code></strong>, <strong><code>min_novel_trans_count</code></strong>, <strong><code>min_single_exon_coverage</code></strong>, <strong><code>min_single_exon_len</code></strong>, <strong><code>thread</code></strong>, <strong><code>tmp_dir</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">RefineWrapper</span><span class="p">:</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processed_collected_multi_exon_read</span><span class="p">,</span> <span class="n">collected_single_exon_read</span><span class="p">,</span> <span class="n">ref_mutple_exon_trans</span><span class="p">,</span> <span class="n">ref_single_exon_trans</span><span class="p">,</span> <span class="n">three_prime_exon</span><span class="p">,</span> <span class="n">tss_dict</span><span class="p">,</span> <span class="n">tss_cutoff</span><span class="p">,</span> <span class="n">tes_cutoff</span><span class="p">,</span> <span class="n">min_novel_trans_count</span><span class="p">,</span> <span class="n">min_single_exon_coverage</span><span class="p">,</span> <span class="n">min_single_exon_len</span><span class="p">,</span> <span class="n">thread</span><span class="p">,</span> <span class="n">tmp_dir</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">processed_collected_multi_exon_read</span> <span class="o">=</span> <span class="n">processed_collected_multi_exon_read</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">collected_single_exon_read</span> <span class="o">=</span> <span class="n">collected_single_exon_read</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ref_mutple_exon_trans</span> <span class="o">=</span> <span class="n">ref_mutple_exon_trans</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ref_single_exon_trans</span> <span class="o">=</span> <span class="n">ref_single_exon_trans</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">three_prime_exon</span> <span class="o">=</span> <span class="n">three_prime_exon</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tss_dict</span> <span class="o">=</span> <span class="n">tss_dict</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tss_cutoff</span> <span class="o">=</span> <span class="n">tss_cutoff</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tes_cutoff</span> <span class="o">=</span> <span class="n">tes_cutoff</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">min_novel_trans_count</span> <span class="o">=</span> <span class="n">min_novel_trans_count</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">min_single_exon_coverage</span> <span class="o">=</span> <span class="n">min_single_exon_coverage</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">min_single_exon_len</span> <span class="o">=</span> <span class="n">min_single_exon_len</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">thread</span> <span class="o">=</span> <span class="n">thread</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tmp_dir</span> <span class="o">=</span> <span class="n">tmp_dir</span>

	<span class="k">def</span> <span class="nf">run1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">multi_precompute_list</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">),</span> <span class="n">chrand_processed_collected_multi_exon_read</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_collected_multi_exon_read</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">multi_precompute_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MultiExonReadRefine</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">chrand_processed_collected_multi_exon_read</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_mutple_exon_trans</span><span class="p">[(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tss_dict</span><span class="p">[(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tss_cutoff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tes_cutoff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_novel_trans_count</span><span class="p">))</span>
		<span class="k">with</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thread</span><span class="p">)</span> <span class="k">as</span> <span class="n">parallel</span><span class="p">:</span>
			<span class="n">multi_exon_results</span> <span class="o">=</span> <span class="n">parallel</span><span class="p">(</span><span class="n">delayed</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">main_refine</span><span class="p">())(</span><span class="n">job</span><span class="p">)</span> <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">multi_precompute_list</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">multi_exon_results</span>

	<span class="k">def</span> <span class="nf">run2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">single_precompute_list</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">),</span> <span class="n">chrand_collected_single_exon_read</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collected_single_exon_read</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">single_precompute_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SingleExonReadRefine</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">chrand_collected_single_exon_read</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_single_exon_trans</span><span class="p">[(</span><span class="n">chrom</span><span class="p">,</span><span class="n">strand</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_mutple_exon_trans</span><span class="p">[(</span><span class="n">chrom</span><span class="p">,</span><span class="n">strand</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">three_prime_exon</span><span class="p">[(</span><span class="n">chrom</span><span class="p">,</span><span class="n">strand</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_single_exon_coverage</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_single_exon_len</span><span class="p">))</span>
		<span class="k">with</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thread</span><span class="p">)</span> <span class="k">as</span> <span class="n">parallel</span><span class="p">:</span>
			<span class="n">single_exon_results</span> <span class="o">=</span> <span class="n">parallel</span><span class="p">(</span><span class="n">delayed</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">.</span><span class="n">refine</span><span class="p">())(</span><span class="n">job</span><span class="p">)</span> <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">single_precompute_list</span><span class="p">)</span>
		
		<span class="k">return</span> <span class="n">single_exon_results</span>


	<span class="k">def</span> <span class="nf">result_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">multi_exon_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run1</span><span class="p">()</span>
		<span class="n">single_exon_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run2</span><span class="p">()</span>
		<span class="n">collected_refined_isoforms</span> <span class="o">=</span> <span class="n">Vividict</span><span class="p">()</span>
		<span class="n">path_to_refine_log</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tmp_dir</span><span class="si">}</span><span class="s1">/refine.log&#39;</span>
		<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">multi_exon_results</span><span class="p">):</span>
			<span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">refined_multi_exon_read</span><span class="p">,</span> <span class="n">refine_log</span> <span class="o">=</span> <span class="n">result</span>
			<span class="k">for</span> <span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">read_attribute</span> <span class="ow">in</span> <span class="n">refined_multi_exon_read</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
					<span class="n">corrected_read_splicing</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_attribute</span><span class="o">.</span><span class="n">end</span><span class="p">,)</span> <span class="o">+</span> <span class="n">corrected_read_splicing</span> <span class="o">+</span> <span class="p">(</span><span class="n">read_attribute</span><span class="o">.</span><span class="n">start</span><span class="p">,)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">corrected_read_splicing</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_attribute</span><span class="o">.</span><span class="n">start</span><span class="p">,)</span> <span class="o">+</span> <span class="n">corrected_read_splicing</span> <span class="o">+</span> <span class="p">(</span><span class="n">read_attribute</span><span class="o">.</span><span class="n">end</span><span class="p">,)</span>
				<span class="n">collected_refined_isoforms</span><span class="p">[(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">)][</span><span class="n">corrected_read_splicing</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_attribute</span>
			<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_to_refine_log</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">flog</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">read_attribute</span> <span class="ow">in</span> <span class="n">refine_log</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
					<span class="n">corrected_read_splicing</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">corrected_read_splicing</span><span class="p">])</span>
					<span class="n">read_attribute</span> <span class="o">=</span> <span class="n">read_attribute</span><span class="o">.</span><span class="vm">__dict__</span>
					<span class="n">read_attribute</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">read_attribute</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
					<span class="n">flog</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">corrected_read_splicing</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">read_attribute</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">single_exon_results</span><span class="p">:</span>
			<span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">refined_single_exon_read</span> <span class="o">=</span> <span class="n">result</span>
			<span class="k">for</span> <span class="n">corrected_read_splicing</span><span class="p">,</span> <span class="n">read_attribute</span> <span class="ow">in</span> <span class="n">refined_single_exon_read</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">collected_refined_isoforms</span><span class="p">[(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">strand</span><span class="p">)][</span><span class="n">corrected_read_splicing</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_attribute</span>
		
		<span class="n">collected_refined_isoforms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">collected_refined_isoforms</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

		<span class="k">return</span> <span class="n">collected_refined_isoforms</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

